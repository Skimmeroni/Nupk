#!/bin/sh

set -u

# Where the installation scripts live
NUPK_REPOSITORY="/var/db/nupk/repository"
# Where the manifest files live
NUPK_INSTALLED="/var/db/nupk/installed"
# Where the (g)zipped packages live
NUPK_BINARIES="/var/cache/nupk"
# Where packages are built
NUPK_WORKDIR="/var/tmp/nupk"

error_message() {
	printf "\033[31;1m@\033[0m \033[1m%s\033[0m\n" "$1"
}

ok_message() {
	printf "\033[32;1m@\033[0m \033[1m%s\033[0m\n" "$1"
}

warning_message() {
	printf "\033[33;1m@\033[0m \033[1m%s\033[0m\n" "$1"
}

fetch_latest_release() {
	V=$(curl -s -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64)" \
	    "https://repology.org/api/v1/project/$PRETTY_NAME" | \
	    jq -r --arg pretty_name "$PRETTY_NAME" --arg name "$PACKAGE_NAME" \
	    'map(select(.srcname == $pretty_name or .srcname == $name) | select(.status == "newest" or .status == "unique") | .version) | unique | max' | \
	    tr '\-,\_' '.')

	printf "%s\n" "$V"
}

ask_for_cleanup() {
	printf "\033[1mYour response: [Y/n] \033[0m"
	read -r REPLY
	if [ "$REPLY" = 'Y' ] || [ "$REPLY" = 'y' ]
	then
		rm -rf "$1"
		ok_message "Removed $1"
	else
		warning_message "$1 untouched"
	fi
}

fetch_variables() {
	# Check if the package actually exist
	if [ ! -d "$NUPK_REPOSITORY/$1" ]
	then
		error_message "Package $OPTARG does not exist!"
		exit 1
	fi

	# $OPTARG is in the form PACKAGE_CLASS/PACKAGE_NAME
	export PACKAGE_CLASS="${1%/*}"
	export PACKAGE_NAME="${1#*/}"
	export SCRIPT_NAME="build-$PACKAGE_NAME.sh"

	# Does a script actually exist?
	if [ ! -f "$NUPK_REPOSITORY/$1/$SCRIPT_NAME" ]
	then
		error_message "A build script for this package could not be found!"
		exit 1
	fi

	# Very stupid hack until we wrap the scripts content into a function
	# . ./"$NUPK_REPOSITORY/$1/$SCRIPT_NAME"
	export VERSION=$(grep '^VERSION' "$NUPK_REPOSITORY/$1/$SCRIPT_NAME" | cut -d = -f 2)
	export PRETTY_NAME=$(grep '^PRETTY_NAME' "$NUPK_REPOSITORY/$1/$SCRIPT_NAME" | cut -d = -f 2)

	# Is the VERSION variable around?
	if [ -z "$VERSION" ]
	then
		error_message "The build script for $1 does not contain a VERSION variable!"
		exit 1
	fi

	# Is the PRETTY_NAME variable around?
	if [ -z "$PRETTY_NAME" ]
	then
		error_message "The build script for $1 does not contain a PRETTY_NAME variable!"
		exit 1
	fi

	export PACKAGE_TARBALL="$PACKAGE_CLASS-$PACKAGE_NAME@$VERSION.tar.gz"
}

check_argnum() {
	if [ "$1" != $(($2 - 1)) ]
	then
		error_message "Wrong number of arguments: expected $1, got $(($2 - 1))"
		exit 1
	fi
}

# b) build a package
# i) install a package
# TODO v) validate a manifest file
# c) compare the current version and the latest version known to Repology
# u) compare all current versions and the latest versions known to Repology
# t) generate a template

while getopts "b:c:t:i:u" op
do
	# Check if the main directories exist
	# TODO: also check if their permissions have been set properly
	for i in NUPK_REPOSITORY NUPK_INSTALLED NUPK_BINARIES NUPK_WORKDIR
	do
		D=$(eval 'printf ${'"$i"'}')
		if [ ! -e "$D" ]
		then
			error_message "Directory $i, set as $D, does not exist!"
			exit 1
		fi
	done

	case $op in
	b)
		# Prevent root from running a build script
		if [ "$(id -u)" = 0 ]
		then
			error_message "Only non-root users can build packages"
			exit 1
		fi

		check_argnum 1 $#
		fetch_variables "$OPTARG"

		# Where the build will take place
		BUILDIR="$NUPK_WORKDIR/$PACKAGE_CLASS-$PACKAGE_NAME"

		# Stop if the remnants of a previous build attempt are found
		if [ -d "$BUILDIR" ]
		then
			warning_message "Directory $BUILDIR already exists! Remove it now?"
			ask_for_cleanup "$BUILDIR"
			# If the directory is still there, i.e. the answer was 'no',
			# respect said choice
			[ ! -d "$BUILDIR" ] || exit
		fi

		# Copy the entire directory
		ok_message "Copying build script and related material..."
		cp -r "$NUPK_REPOSITORY/$OPTARG" "$BUILDIR"
		cd "$BUILDIR"

		# Build the package
		ok_message "Building directory prepared. Building $OPTARG"
		./"$SCRIPT_NAME"

		# Bail out on failure
		if [ $? != 0 ]
		then
			error_message "Something has gone terribly wrong!"

			# Cleanup, if desired
			warning_message "Remove leftovers in $BUILDIR?"
			ask_for_cleanup "$BUILDIR"

			error_message "Building $OPTARG failed!"
			exit 1
		fi

		if [ ! -f "$PACKAGE_TARBALL" ]
		then
			error_message "$PACKAGE_TARBALL not found!"

			warning_message "Remove leftovers in $BUILDIR?"
			ask_for_cleanup "$BUILDIR"
			exit 1
		fi

		# Move the archive to $NUPK_BINARIES
		mv "$PACKAGE_TARBALL" "$NUPK_BINARIES"
		ok_message "$OPTARG built and saved in $NUPK_BINARIES"

		# Cleanup, if desired
		warning_message "Remove leftovers in $BUILDIR?"
		ask_for_cleanup "$BUILDIR"
		;;
	c)
		check_argnum 1 $#
		fetch_variables "$OPTARG"

		REPOLOGY_VERSION=$(fetch_latest_release "$OPTARG")
		printf "You have: %s\nRepology has: %s\n" "$VERSION" "$REPOLOGY_VERSION"
		;;
	t)
		check_argnum 5 $#

		# Note: not exactly foolproof, but should return a template
		# that is reasonably complete
		SOURCES_STUB=""
		EXTENSION="${5##*.}"
		FILE=$(basename "$5")
		if [ "$EXTENSION" = "git" ]
		then
			SOURCES_STUB="git clone $5\n\ncd $FILE"
		else
			SOURCES_STUB="curl --location --remote-name --skip-existing $5"
			case $EXTENSION in
			"gz") SOURCES_STUB="$SOURCES_STUB\n\ngzip -cd $FILE | tar -x\ncd ???" ;;
			"xz") SOURCES_STUB="$SOURCES_STUB\n\nxz -cd $FILE | tar -x\ncd ???" ;;
			"bz2") SOURCES_STUB="$SOURCES_STUB\n\nbzip2 -cd $FILE | tar -x\ncd ???" ;;
			"lz") SOURCES_STUB="$SOURCES_STUB\n\nlzip -cd $FILE | tar -x\ncd ???" ;;
			"zip") SOURCES_STUB="$SOURCES_STUB\n\nunzip $FILE\ncd ???" ;;
			*) ;;
			esac
		fi

		BUILD_STUB=""
		case "$6" in
		"meson")
			BUILD_STUB="\
			meson setup \\\\\n\
			-D prefix=/usr \\\\\n\
			-D buildtype=release \\\\\n\
			-D wrap_mode=nofallback \\\\\n\
			-D default_library=both \\\\\n\
			-D strip=true \\\\\n\
			#-D ??? \\\\\n\
			build\n\
			\n\
			meson compile -C build --verbose\n\
			meson install -C build --destdir \$DESTDIR"
			;;
		"make")
			BUILD_STUB="\
			make\n\
			make DESTDIR=\$DESTDIR install"
			;;
		"cmake")
			BUILD_STUB="\
			cmake -B build \\\\\n\
			-D CMAKE_INSTALL_PREFIX=/usr \\\\\n\
			-D CMAKE_BUILD_TYPE=Release \\\\\n\
			#-D ??? \\\\\n\
			-G Ninja\n\
			\n\
			cmake --build build --verbose\n\
			DESTDIR=\$DESTDIR cmake --install build --strip"
			;;
		"configure")
			BUILD_STUB="\
			./configure \\\\\n\
			--prefix=/usr \\\\\n\
			--enable-shared \\\\\n\
			--enable-static \\\\\n\
			#--??? \n\
			\n\
			make\n\
			make DESTDIR=\$DESTDIR install-strip"
			;;
		"gpep")
			BUILD_STUB="gpep517 install-from-source --optimize all --destdir \$DESTDIR"
			;;
		*) ;;
		esac

		printf "\
		#!/bin/sh\n\
		\n\
		set -eu\n\
		\n\
		PRETTY_NAME=%s\n\
		MAJOR=\n\
		MINOR=\n\
		PATCH=\n\
		VERSION=%s\n\
		\n\
		DESTDIR=\"\$PWD/temporary-destdir\"\n\
		[ -d \$DESTDIR ] || mkdir -p \$DESTDIR\n\
		\n\
		$SOURCES_STUB\n\
		\n\
		$BUILD_STUB\n\
		\n\
		doas chown -R root:root \$DESTDIR\n\
		cd \$DESTDIR\n\
		doas sh -c \"tar -cf - * | gzip > ../%s-%s@\$VERSION.tar.gz\"\n\
		doas rm -rf \$DESTDIR\n" "$3" "$4" "$2" "$3" | tr -d '\t'
		;;
	i)
		# Packages have to be installed as root
		if [ "$(id -u)" != 0 ]
		then
			error_message "Only root can install packages"
			exit 1
		fi

		check_argnum 1 $#
		fetch_variables "$OPTARG"

		# Check if the tarball exists
		if [ ! -f "$NUPK_BINARIES/$PACKAGE_TARBALL" ]
		then
			error_message "Could not find $PACKAGE_TARBALL! Have you built the package?"
			exit 1
		fi

		# Create a manifest file
		PACKAGE_MANIFEST="$PACKAGE_CLASS-$PACKAGE_NAME.manifest"
		tar -tf "$NUPK_BINARIES/$PACKAGE_TARBALL" | sort -r | sed 's|^|/|g' > "/tmp/$PACKAGE_MANIFEST.new"

		# Check if the package is to be installed anew or of it is to be updated
		LEFTOVERS=
		if [ -f "$NUPK_INSTALLED/$PACKAGE_MANIFEST" ]
		then
			# It would be much simpler to use comm, but it does not work here
			LEFTOVERS=$(diff -U 0 "$NUPK_INSTALLED/$PACKAGE_MANIFEST" "/tmp/$PACKAGE_MANIFEST.new" | grep -E '^-/' | sed 's|^-||g')

			if [ -z "$LEFTOVERS" ]
			then
				ok_message "No leftovers to remove"
			else
				warning_message "Remove the following leftover files?"
				printf "%s\n" "$LEFTOVERS"

				printf "\033[1mYour response: [Y/n] \033[0m"
				read -r REPLY
				if [ "$REPLY" = 'N' ] || [ "$REPLY" = 'n' ]
				then
					exit
				fi
			fi
		fi

		# Extract the content to / and move the manifest file
		# TODO: this is not POSIX!
		ok_message "Unpacking..."
		tar -xpf "$NUPK_BINARIES/$PACKAGE_TARBALL" -C /
		mv "/tmp/$PACKAGE_MANIFEST.new" "$NUPK_INSTALLED/$PACKAGE_MANIFEST"

		# Remove leftovers, if there are any
		if [ -n "$LEFTOVERS" ]
		then
			ok_message "Removing files from the previous version..."
			for t in $LEFTOVERS
			do
				if [ -h "$t" ]
				then
					unlink "$t"
				elif [ -f "$t" ]
				then
					rm "$t"
				elif [ -d "$t" ]
				then
					rmdir "$t"
				fi
			done
		fi

		sync
		ok_message "Installed $OPTARG"
		;;
	u)
		# NOTE: shaky
		for i in $(cd $NUPK_REPOSITORY; find * -type d -mindepth 1)
		do
			fetch_variables "$i"
			REPOLOGY_VERSION=$(fetch_latest_release "$i")

			if [ "$VERSION" = "git" ]
			then
				ok_message "$i ignored (cloned from git repo)"
			elif [ "$REPOLOGY_VERSION" = "null" ]
			then
				error_message "$i not found!"
			# Remove trailing zeros to remove ambiguity
			elif [ "${VERSION%.0*}" != "${REPOLOGY_VERSION%.0*}" ]
			then
				warning_message "$i can be upgraded from $VERSION to $REPOLOGY_VERSION"
			fi
		done
		;;
	*)
		error_message "What? Valid options are -b, -c, -t, -i -u"
		;;
	esac
done
